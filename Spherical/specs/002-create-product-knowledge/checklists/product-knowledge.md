# Product Knowledge Requirements Checklist: Product Knowledge Engine Library

**Purpose**: Validate the requirement quality across ingestion, retrieval, comparison, and monitoring surfaces for the Product Knowledge Engine before release.
**Created**: 2025-11-28
**Feature**: [spec.md](../spec.md)

**Note**: This checklist is generated by the `/speckit.checklist` command with a release-gate depth; focus on written requirements rather than implementation behavior.

## Requirement Completeness

- [x] CHK001 - Are the multi-tenant tagging and row-level-security obligations spelled out for every record type so ingestion, retrieval, and comparison flows share the same `tenant_id/product_id/campaign_variant_id/visibility` expectations? [Completeness, Spec §FR-001]

- [x] CHK002 - Is the full ingestion pipeline defined to accept Markdown from the PDF extractor and JSON uploads, normalize spec categories, dedupe conflicting values, and gate publishing until conflicts clear? [Completeness, Spec §FR-002; Spec §FR-003; Spec §User Story 1 (acceptance scenarios 1–3)]

- [x] CHK003 - Are publish/rollback/versioning requirements described with the transactional states (`version`, `effective_from`, `effective_through`, `is_draft`) and tenant isolation guarantees that prevent other tenants from seeing drafts? [Completeness, Spec §FR-004; Spec §User Story 1 (acceptance scenario 2)]

- [x] CHK004 - Do the requirements cover every consumer surface (REST/GraphQL/gRPC/CLI/Go SDK plus export/import tooling) so structured specs, semantic chunks, and comparisons are always reachable? [Completeness, Spec §FR-011; Spec §FR-015]

## Requirement Clarity

- [x] CHK005 - Is the hybrid retrieval intent-classification threshold defined with measurable priority rules (structured first, semantic fallback, cache fallback) so operators know when SQL, vector, or hybrid paths run? [Clarity, Spec §FR-006]

- [x] CHK006 - Are knowledge chunk metadata requirements (category, chunk_type, embedding_version) and filtered search expectations articulated clearly so vectors returned by FAISS or PGVector match the required payload? [Clarity, Spec §FR-005; Spec §FR-007]

- [x] CHK007 - Are the performance targets for ingestion (≤15 minutes for a 20-page brochure) and retrieval (≤150 ms p50, ≤350 ms p95) spelled out per environment (SQLite/FAISS dev vs Postgres/PGVector prod) so measurable criteria exist? [Clarity, Spec §FR-008; Spec §SC-001; Spec §SC-002]

- [x] CHK008 - Are OAuth2 client-credential flows, mTLS requirements, RBAC roles, and retention obligations described with specific lifetimes, allowed scopes, and rollback tolerances versus the current placeholders? [Clarity, Spec §FR-016; Spec §FR-017; Spec §FR-018]

## Requirement Consistency

- [x] CHK009 - Do audit/logging requirements mention the same payload (operator identity, request summary, affected IDs) across ingestion, retrieval, comparison, and monitoring so no surface omits mandated fields? [Consistency, Spec §FR-010]

- [x] CHK010 - Are intent classification, cache filtering, and vector search requirements aligned with the multi-tenant tagging schema so conflicting filters cannot leak tenant data? [Consistency, Spec §FR-001; Spec §FR-006; Spec §FR-007]

- [x] CHK011 - Is the CLI-first principle consistent with the REST/GraphQL/gRPC/SDK surfaces and instrumentation story documented under the project structure so operators see the same capabilities in every interface? [Consistency, Plan §Project Structure]

## Acceptance Criteria Quality

- [x] CHK012 - Are the measurable success criteria (SC-001 through SC-005) tied directly to the stories they gate so reviewers can objectively tell when ingestion, retrieval, comparison, and drift meet the release bar? [Acceptance Criteria, Spec §SC-001; Spec §SC-002; Spec §SC-003; Spec §SC-004; Spec §SC-005]

- [x] CHK013 - Do the acceptance scenarios for User Stories 1–4 enumerate clear given/when/then flows with expected data scopes, so each story stays independently testable? [Acceptance Criteria, Spec §User Story 1; Spec §User Story 2; Spec §User Story 3; Spec §User Story 4]

- [x] CHK014 - Are lineage/drift monitoring outcomes quantified (alert windows, refresh thresholds, retention) so analysts know what success looks like when they query or purge campaigns? [Acceptance Criteria, Spec §SC-005]

## Scenario Coverage

- [x] CHK015 - Are the primary flows for campaign ingestion (US1), retrieval (US2), comparison (US3), and drift lineage (US4) described end-to-end with inputs/outputs and success states? [Coverage, Spec §User Story 1; Spec §User Story 2; Spec §User Story 3; Spec §User Story 4]

- [x] CHK016 - Are alternate flows such as mis-specified trims, semantic fallback responses, and competition denials captured with detailed requirements so the router behaviour is predictable? [Coverage, Spec §User Story 2 (acceptance scenario 2); Spec §User Story 3 (acceptance scenario 2)]

- [x] CHK017 - Are recovery pathways (publish rollback, conflict status gating, drift alert triggers) defined with the steps needed to restore safe states after failures? [Coverage, Spec §FR-004; Spec §Edge Cases]

- [x] CHK018 - Are exception scenarios (conflicting numeric values, tenant campaign deletions mid-session, embedding-version mixes, unauthorized comparison requests) addressed so every branch documents expected outcomes and logging? [Coverage, Spec §Edge Cases]

## Edge Case Coverage

- [x] CHK019 - Are the rules for handling conflicting numeric brochure values defined with how the system demotes lower-confidence rows and prevents publishing until resolved? [Edge Case, Spec §Edge Cases]

- [x] CHK020 - Is the retrieval behaviour when a tenant deletes a campaign mid-conversation documented (fallback to previous publish, safe “information unavailable” message) so agents never surface deleted data? [Edge Case, Spec §Edge Cases]

- [x] CHK021 - Are embedding-version mismatches and unauthorized competitor comparisons spelled out with the filters, rejection responses, and audit logging required to enforce policy? [Edge Case, Spec §Edge Cases]

## Non-Functional Requirements

- [x] CHK022 - Are the latency and throughput budgets for dev (SQLite+FAISS) versus prod (Postgres+PGVector) explicitly defined so teams can measure compliance with SC-001/SC-002? [Non-Functional, Spec §FR-012; Spec §SC-002]

- [x] CHK023 - Are the security requirements for OAuth2/mTLS, RBAC roles, retention (5-year data, 30-day purge), and audit trails described with measurable checkpoints so compliance can be independently verified? [Non-Functional, Spec §FR-016; Spec §FR-017]

- [x] CHK024 - Are cache/Redis/FAISS/PGVector availability, TTL, and eviction behaviour spelled out with tenant-aware controls so hot spec lookups remain accurate? [Non-Functional, Spec §FR-013]

- [x] CHK025 - Are drift detection thresholds, alert timing, and purge completion goals documented with the exact triggers that satisfy SC-005? [Non-Functional, Spec §FR-014; Spec §SC-005]

## Dependencies & Assumptions

- [x] CHK026 - Are dependencies on the `pdf-extractor` CLI, benchmark/competition data, and ingestion connectors documented so the release gate verifies the upstream tools exist and behave as required? [Dependencies, Spec §User Story 1 (acceptance scenario 3); Spec §User Story 3]

- [x] CHK027 - Are infrastructure assumptions (SQLite/FAISS for local dev, Postgres/PGVector/Redis in prod, CLI-first operations) documented so every environment can claim readiness before release? [Dependencies, Plan §Technical Context; Spec §FR-012]

## Ambiguities & Conflicts

- [x] CHK028 - Is the term “deterministic pipeline” quantified with the validation, rollback, and logging rules needed to avoid ambiguity between FR-002 and FR-003? [Ambiguity, Spec §FR-002; Spec §FR-003]

- [x] CHK029 - Are there any unresolved conflicts between the CLI-first approach and the multi-protocol API surfaces or between OAuth/mTLS requirements and CLI credentials that need reconciliation before release? [Conflict, Spec §FR-011; Spec §FR-016; Spec §FR-018]

## Notes

- Items should remain focused on requirement wording; do not test implementation behaviour.
- Add trace IDs or section references when updating requirements so future reviewers can link checks back to explicit sections.
